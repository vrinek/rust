<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Compound Data Types</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a href='basic.html'><b>2.</b> I: The Basics</a>
<ul class='section'>
<li><a href='installing-rust.html'><b>2.1.</b> Installing Rust</a>
</li>
<li><a href='hello-world.html'><b>2.2.</b> Hello, world!</a>
</li>
<li><a href='hello-cargo.html'><b>2.3.</b> Hello, Cargo!</a>
</li>
<li><a href='variable-bindings.html'><b>2.4.</b> Variable Bindings</a>
</li>
<li><a href='if.html'><b>2.5.</b> If</a>
</li>
<li><a href='functions.html'><b>2.6.</b> Functions</a>
</li>
<li><a href='comments.html'><b>2.7.</b> Comments</a>
</li>
<li><a href='compound-data-types.html'><b>2.8.</b> Compound Data Types</a>
</li>
<li><a href='match.html'><b>2.9.</b> Match</a>
</li>
<li><a href='looping.html'><b>2.10.</b> Looping</a>
</li>
<li><a href='strings.html'><b>2.11.</b> Strings</a>
</li>
<li><a href='arrays-vectors-and-slices.html'><b>2.12.</b> Arrays, Vectors, and Slices</a>
</li>
<li><a href='standard-input.html'><b>2.13.</b> Standard Input</a>
</li>
<li><a href='guessing-game.html'><b>2.14.</b> Guessing Game</a>
</li>
</ul>
</li>
<li><a href='intermediate.html'><b>3.</b> II: Intermediate Rust</a>
<ul class='section'>
<li><a href='more-strings.html'><b>3.1.</b> More Strings</a>
</li>
<li><a href='crates-and-modules.html'><b>3.2.</b> Crates and Modules</a>
</li>
<li><a href='testing.html'><b>3.3.</b> Testing</a>
</li>
<li><a href='pointers.html'><b>3.4.</b> Pointers</a>
</li>
<li><a href='ownership.html'><b>3.5.</b> Ownership</a>
</li>
<li><a href='patterns.html'><b>3.6.</b> Patterns</a>
</li>
<li><a href='method-syntax.html'><b>3.7.</b> Method Syntax</a>
</li>
<li><a href='closures.html'><b>3.8.</b> Closures</a>
</li>
<li><a href='iterators.html'><b>3.9.</b> Iterators</a>
</li>
<li><a href='generics.html'><b>3.10.</b> Generics</a>
</li>
<li><a href='traits.html'><b>3.11.</b> Traits</a>
</li>
<li><a href='threads.html'><b>3.12.</b> Threads</a>
</li>
<li><a href='error-handling.html'><b>3.13.</b> Error Handling</a>
</li>
<li><a href='documentation.html'><b>3.14.</b> Documentation</a>
</li>
</ul>
</li>
<li><a href='advanced.html'><b>4.</b> III: Advanced Topics</a>
<ul class='section'>
<li><a href='ffi.html'><b>4.1.</b> FFI</a>
</li>
<li><a href='unsafe.html'><b>4.2.</b> Unsafe Code</a>
</li>
<li><a href='macros.html'><b>4.3.</b> Macros</a>
</li>
<li><a href='plugins.html'><b>4.4.</b> Compiler Plugins</a>
</li>
</ul>
</li>
<li><a href='conclusion.html'><b>5.</b> Conclusion</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Compound Data Types</h1>
    <p>Rust, like many programming languages, has a number of different data types
that are built-in. You&#39;ve already done some simple work with integers and
strings, but next, let&#39;s talk about some more complicated ways of storing data.</p>

<h2 id="tuples" class='section-header'><a
                           href="#tuples">Tuples</a></h2>
<p>The first compound data type we&#39;re going to talk about are called <em>tuples</em>.
Tuples are an ordered list of a fixed size. Like this:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> (<span class='number'>1</span>, <span class='string'>&quot;hello&quot;</span>);
</pre>

<p>The parentheses and commas form this two-length tuple. Here&#39;s the same code, but
with the type annotated:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span>: (<span class='ident'>i32</span>, <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>=</span> (<span class='number'>1</span>, <span class='string'>&quot;hello&quot;</span>);
</pre>

<p>As you can see, the type of a tuple looks just like the tuple, but with each
position having a type name rather than the value. Careful readers will also
note that tuples are heterogeneous: we have an <code>i32</code> and a <code>&amp;str</code> in this tuple.
You have briefly seen <code>&amp;str</code> used as a type before, and we&#39;ll discuss the
details of strings later. In systems programming languages, strings are a bit
more complex than in other languages. For now, just read <code>&amp;str</code> as a <em>string
slice</em>, and we&#39;ll learn more soon.</p>

<p>You can access the fields in a tuple through a <em>destructuring let</em>. Here&#39;s
an example:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> (<span class='ident'>x</span>, <span class='ident'>y</span>, <span class='ident'>z</span>) <span class='op'>=</span> (<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>);

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x is {}&quot;</span>, <span class='ident'>x</span>);
</pre>

<p>Remember before when I said the left-hand side of a <code>let</code> statement was more
powerful than just assigning a binding? Here we are. We can put a pattern on
the left-hand side of the <code>let</code>, and if it matches up to the right-hand side,
we can assign multiple bindings at once. In this case, <code>let</code> &quot;destructures,&quot;
or &quot;breaks up,&quot; the tuple, and assigns the bits to three bindings.</p>

<p>This pattern is very powerful, and we&#39;ll see it repeated more later.</p>

<p>There are also a few things you can do with a tuple as a whole, without
destructuring. You can assign one tuple into another, if they have the same
arity and contained types.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> (<span class='number'>1</span>, <span class='number'>2</span>); <span class='comment'>// x: (i32, i32)</span>
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> (<span class='number'>2</span>, <span class='number'>3</span>); <span class='comment'>// y: (i32, i32)</span>

<span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>y</span>;
</pre>

<p>You can also check for equality with <code>==</code>. Again, this will only compile if the
tuples have the same type.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> (<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>);
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> (<span class='number'>2</span>, <span class='number'>2</span>, <span class='number'>4</span>);

<span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>==</span> <span class='ident'>y</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;yes&quot;</span>);
} <span class='kw'>else</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;no&quot;</span>);
}
</pre>

<p>This will print <code>no</code>, because some of the values aren&#39;t equal.</p>

<p>One other use of tuples is to return multiple values from a function:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>next_two</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> (<span class='ident'>i32</span>, <span class='ident'>i32</span>) { (<span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>, <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>2</span>) }

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> (<span class='ident'>x</span>, <span class='ident'>y</span>) <span class='op'>=</span> <span class='ident'>next_two</span>(<span class='number'>5</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x, y = {}, {}&quot;</span>, <span class='ident'>x</span>, <span class='ident'>y</span>);
}
</pre>

<p>Even though Rust functions can only return one value, a tuple <em>is</em> one value,
that happens to be made up of more than one value. You can also see in this
example how you can destructure a pattern returned by a function, as well.</p>

<p>Tuples are a very simple data structure, and so are not often what you want.
Let&#39;s move on to their bigger sibling, structs.</p>

<h2 id="structs" class='section-header'><a
                           href="#structs">Structs</a></h2>
<p>A struct is another form of a <em>record type</em>, just like a tuple. There&#39;s a
difference: structs give each element that they contain a name, called a
<em>field</em> or a <em>member</em>. Check it out:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>struct</span> <span class='ident'>Point</span> {
    <span class='ident'>x</span>: <span class='ident'>i32</span>,
    <span class='ident'>y</span>: <span class='ident'>i32</span>,
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>origin</span> <span class='op'>=</span> <span class='ident'>Point</span> { <span class='ident'>x</span>: <span class='number'>0</span>, <span class='ident'>y</span>: <span class='number'>0</span> }; <span class='comment'>// origin: Point</span>

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The origin is at ({}, {})&quot;</span>, <span class='ident'>origin</span>.<span class='ident'>x</span>, <span class='ident'>origin</span>.<span class='ident'>y</span>);
}
</pre>

<p>There&#39;s a lot going on here, so let&#39;s break it down. We declare a struct with
the <code>struct</code> keyword, and then with a name. By convention, structs begin with a
capital letter and are also camel cased: <code>PointInSpace</code>, not <code>Point_In_Space</code>.</p>

<p>We can create an instance of our struct via <code>let</code>, as usual, but we use a <code>key:
value</code> style syntax to set each field. The order doesn&#39;t need to be the same as
in the original declaration.</p>

<p>Finally, because fields have names, we can access the field through dot
notation: <code>origin.x</code>.</p>

<p>The values in structs are immutable by default, like other bindings in Rust.
Use <code>mut</code> to make them mutable:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>struct</span> <span class='ident'>Point</span> {
    <span class='ident'>x</span>: <span class='ident'>i32</span>,
    <span class='ident'>y</span>: <span class='ident'>i32</span>,
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>point</span> <span class='op'>=</span> <span class='ident'>Point</span> { <span class='ident'>x</span>: <span class='number'>0</span>, <span class='ident'>y</span>: <span class='number'>0</span> };

    <span class='ident'>point</span>.<span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The point is at ({}, {})&quot;</span>, <span class='ident'>point</span>.<span class='ident'>x</span>, <span class='ident'>point</span>.<span class='ident'>y</span>);
}
</pre>

<p>This will print <code>The point is at (5, 0)</code>.</p>

<h2 id="tuple-structs-and-newtypes" class='section-header'><a
                           href="#tuple-structs-and-newtypes">Tuple Structs and Newtypes</a></h2>
<p>Rust has another data type that&#39;s like a hybrid between a tuple and a struct,
called a <em>tuple struct</em>. Tuple structs do have a name, but their fields don&#39;t:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>struct</span> <span class='ident'>Color</span>(<span class='ident'>i32</span>, <span class='ident'>i32</span>, <span class='ident'>i32</span>);
<span class='kw'>struct</span> <span class='ident'>Point</span>(<span class='ident'>i32</span>, <span class='ident'>i32</span>, <span class='ident'>i32</span>);
</pre>

<p>These two will not be equal, even if they have the same values:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>black</span> <span class='op'>=</span> <span class='ident'>Color</span>(<span class='number'>0</span>, <span class='number'>0</span>, <span class='number'>0</span>);
<span class='kw'>let</span> <span class='ident'>origin</span> <span class='op'>=</span> <span class='ident'>Point</span>(<span class='number'>0</span>, <span class='number'>0</span>, <span class='number'>0</span>);
</pre>

<p>It is almost always better to use a struct than a tuple struct. We would write
<code>Color</code> and <code>Point</code> like this instead:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>struct</span> <span class='ident'>Color</span> {
    <span class='ident'>red</span>: <span class='ident'>i32</span>,
    <span class='ident'>blue</span>: <span class='ident'>i32</span>,
    <span class='ident'>green</span>: <span class='ident'>i32</span>,
}

<span class='kw'>struct</span> <span class='ident'>Point</span> {
    <span class='ident'>x</span>: <span class='ident'>i32</span>,
    <span class='ident'>y</span>: <span class='ident'>i32</span>,
    <span class='ident'>z</span>: <span class='ident'>i32</span>,
}
</pre>

<p>Now, we have actual names, rather than positions. Good names are important,
and with a struct, we have actual names.</p>

<p>There <em>is</em> one case when a tuple struct is very useful, though, and that&#39;s a
tuple struct with only one element. We call this a <em>newtype</em>, because it lets
you create a new type that&#39;s similar to another one:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>struct</span> <span class='ident'>Inches</span>(<span class='ident'>i32</span>);

<span class='kw'>let</span> <span class='ident'>length</span> <span class='op'>=</span> <span class='ident'>Inches</span>(<span class='number'>10</span>);

<span class='kw'>let</span> <span class='ident'>Inches</span>(<span class='ident'>integer_length</span>) <span class='op'>=</span> <span class='ident'>length</span>;
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;length is {} inches&quot;</span>, <span class='ident'>integer_length</span>);
</pre>

<p>As you can see here, you can extract the inner integer type through a
destructuring <code>let</code>, as we discussed previously in &#39;tuples.&#39; In this case, the
<code>let Inches(integer_length)</code> assigns <code>10</code> to <code>integer_length</code>.</p>

<h2 id="enums" class='section-header'><a
                           href="#enums">Enums</a></h2>
<p>Finally, Rust has a &quot;sum type&quot;, an <em>enum</em>. Enums are an incredibly useful
feature of Rust, and are used throughout the standard library. This is an enum
that is provided by the Rust standard library:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>enum</span> <span class='ident'>Ordering</span> {
    <span class='ident'>Less</span>,
    <span class='ident'>Equal</span>,
    <span class='ident'>Greater</span>,
}
</pre>

<p>An <code>Ordering</code> can only be <em>one</em> of <code>Less</code>, <code>Equal</code>, or <code>Greater</code> at any given
time.</p>

<p>Because <code>Ordering</code> is provided by the standard library, we can use the <code>use</code>
keyword to use it in our code. We&#39;ll learn more about <code>use</code> later, but it&#39;s
used to bring names into scope.</p>

<p>Here&#39;s an example of how to use <code>Ordering</code>:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>cmp</span>::<span class='ident'>Ordering</span>;

<span class='kw'>fn</span> <span class='ident'>cmp</span>(<span class='ident'>a</span>: <span class='ident'>i32</span>, <span class='ident'>b</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>Ordering</span> {
    <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&lt;</span> <span class='ident'>b</span> { <span class='ident'>Ordering</span>::<span class='ident'>Less</span> }
    <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&gt;</span> <span class='ident'>b</span> { <span class='ident'>Ordering</span>::<span class='ident'>Greater</span> }
    <span class='kw'>else</span> { <span class='ident'>Ordering</span>::<span class='ident'>Equal</span> }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>10</span>;

    <span class='kw'>let</span> <span class='ident'>ordering</span> <span class='op'>=</span> <span class='ident'>cmp</span>(<span class='ident'>x</span>, <span class='ident'>y</span>); <span class='comment'>// ordering: Ordering</span>

    <span class='kw'>if</span> <span class='ident'>ordering</span> <span class='op'>==</span> <span class='ident'>Ordering</span>::<span class='ident'>Less</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;less&quot;</span>);
    } <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>ordering</span> <span class='op'>==</span> <span class='ident'>Ordering</span>::<span class='ident'>Greater</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;greater&quot;</span>);
    } <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>ordering</span> <span class='op'>==</span> <span class='ident'>Ordering</span>::<span class='ident'>Equal</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;equal&quot;</span>);
    }
}
</pre>

<p>There&#39;s a symbol here we haven&#39;t seen before: the double colon (<code>::</code>).
This is used to indicate a namespace. In this case, <code>Ordering</code> lives in
the <code>cmp</code> submodule of the <code>std</code> module. We&#39;ll talk more about modules
later in the guide. For now, all you need to know is that you can <code>use</code>
things from the standard library if you need them.</p>

<p>Okay, let&#39;s talk about the actual code in the example. <code>cmp</code> is a function that
compares two things, and returns an <code>Ordering</code>. We return either
<code>Ordering::Less</code>, <code>Ordering::Greater</code>, or <code>Ordering::Equal</code>, depending on if
the two values are less, greater, or equal. Note that each variant of the
<code>enum</code> is namespaced under the <code>enum</code> itself: it&#39;s <code>Ordering::Greater</code> not
<code>Greater</code>.</p>

<p>The <code>ordering</code> variable has the type <code>Ordering</code>, and so contains one of the
three values. We can then do a bunch of <code>if</code>/<code>else</code> comparisons to check which
one it is. However, repeated <code>if</code>/<code>else</code> comparisons get quite tedious. Rust
has a feature that not only makes them nicer to read, but also makes sure that
you never miss a case. Before we get to that, though, let&#39;s talk about another
kind of enum: one with values.</p>

<p>This enum has two variants, one of which has a value:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>enum</span> <span class='ident'>OptionalInt</span> {
    <span class='ident'>Value</span>(<span class='ident'>i32</span>),
    <span class='ident'>Missing</span>,
}
</pre>

<p>This enum represents an <code>i32</code> that we may or may not have. In the <code>Missing</code>
case, we have no value, but in the <code>Value</code> case, we do. This enum is specific
to <code>i32</code>s, though. We can make it usable by any type, but we haven&#39;t quite
gotten there yet!</p>

<p>You can also have any number of values in an enum:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>enum</span> <span class='ident'>OptionalColor</span> {
    <span class='ident'>Color</span>(<span class='ident'>i32</span>, <span class='ident'>i32</span>, <span class='ident'>i32</span>),
    <span class='ident'>Missing</span>,
}
</pre>

<p>And you can also have something like this:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>enum</span> <span class='ident'>StringResult</span> {
    <span class='ident'>StringOK</span>(<span class='ident'>String</span>),
    <span class='ident'>ErrorReason</span>(<span class='ident'>String</span>),
}
</pre>

<p>Where a <code>StringResult</code> is either a <code>StringResult::StringOK</code>, with the result of
a computation, or a <code>StringResult::ErrorReason</code> with a <code>String</code> explaining
what caused the computation to fail. These kinds of <code>enum</code>s are actually very
useful and are even part of the standard library.</p>

<p>Here is an example of using our <code>StringResult</code>:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>enum</span> <span class='ident'>StringResult</span> {
    <span class='ident'>StringOK</span>(<span class='ident'>String</span>),
    <span class='ident'>ErrorReason</span>(<span class='ident'>String</span>),
}

<span class='kw'>fn</span> <span class='ident'>respond</span>(<span class='ident'>greeting</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='ident'>StringResult</span> {
    <span class='kw'>if</span> <span class='ident'>greeting</span> <span class='op'>==</span> <span class='string'>&quot;Hello&quot;</span> {
        <span class='ident'>StringResult</span>::<span class='ident'>StringOK</span>(<span class='string'>&quot;Good morning!&quot;</span>.<span class='ident'>to_string</span>())
    } <span class='kw'>else</span> {
        <span class='ident'>StringResult</span>::<span class='ident'>ErrorReason</span>(<span class='string'>&quot;I didn&#39;t understand you!&quot;</span>.<span class='ident'>to_string</span>())
    }
}
</pre>

<p>That&#39;s a lot of typing! We can use the <code>use</code> keyword to make it shorter:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>use</span> <span class='ident'>StringResult</span>::<span class='ident'>StringOK</span>;
<span class='kw'>use</span> <span class='ident'>StringResult</span>::<span class='ident'>ErrorReason</span>;

<span class='kw'>enum</span> <span class='ident'>StringResult</span> {
    <span class='ident'>StringOK</span>(<span class='ident'>String</span>),
    <span class='ident'>ErrorReason</span>(<span class='ident'>String</span>),
}


<span class='kw'>fn</span> <span class='ident'>respond</span>(<span class='ident'>greeting</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='ident'>StringResult</span> {
    <span class='kw'>if</span> <span class='ident'>greeting</span> <span class='op'>==</span> <span class='string'>&quot;Hello&quot;</span> {
        <span class='ident'>StringOK</span>(<span class='string'>&quot;Good morning!&quot;</span>.<span class='ident'>to_string</span>())
    } <span class='kw'>else</span> {
        <span class='ident'>ErrorReason</span>(<span class='string'>&quot;I didn&#39;t understand you!&quot;</span>.<span class='ident'>to_string</span>())
    }
}
</pre>

<p><code>use</code> declarations must come before anything else, which looks a little strange in this example,
since we <code>use</code> the variants before we define them. Anyway, in the body of <code>respond</code>, we can just
say <code>StringOK</code> now, rather than the full <code>StringResult::StringOK</code>. Importing variants can be
convenient, but can also cause name conflicts, so do this with caution. It&#39;s considered good style
to rarely import variants for this reason.</p>

<p>As you can see, <code>enum</code>s with values are quite a powerful tool for data representation,
and can be even more useful when they&#39;re generic across types. Before we get to generics,
though, let&#39;s talk about how to use them with pattern matching, a tool that will
let us deconstruct this sum type (the type theory term for enums) in a very elegant
way and avoid all these messy <code>if</code>/<code>else</code>s.</p>

    <script type="text/javascript">
        window.playgroundUrl = "";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceeding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
</div></div>


</body>
</html>