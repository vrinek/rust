<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Macros</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a href='basic.html'><b>2.</b> I: The Basics</a>
<ul class='section'>
<li><a href='installing-rust.html'><b>2.1.</b> Installing Rust</a>
</li>
<li><a href='hello-world.html'><b>2.2.</b> Hello, world!</a>
</li>
<li><a href='hello-cargo.html'><b>2.3.</b> Hello, Cargo!</a>
</li>
<li><a href='variable-bindings.html'><b>2.4.</b> Variable Bindings</a>
</li>
<li><a href='if.html'><b>2.5.</b> If</a>
</li>
<li><a href='functions.html'><b>2.6.</b> Functions</a>
</li>
<li><a href='comments.html'><b>2.7.</b> Comments</a>
</li>
<li><a href='compound-data-types.html'><b>2.8.</b> Compound Data Types</a>
</li>
<li><a href='match.html'><b>2.9.</b> Match</a>
</li>
<li><a href='looping.html'><b>2.10.</b> Looping</a>
</li>
<li><a href='strings.html'><b>2.11.</b> Strings</a>
</li>
<li><a href='arrays-vectors-and-slices.html'><b>2.12.</b> Arrays, Vectors, and Slices</a>
</li>
<li><a href='standard-input.html'><b>2.13.</b> Standard Input</a>
</li>
<li><a href='guessing-game.html'><b>2.14.</b> Guessing Game</a>
</li>
</ul>
</li>
<li><a href='intermediate.html'><b>3.</b> II: Intermediate Rust</a>
<ul class='section'>
<li><a href='more-strings.html'><b>3.1.</b> More Strings</a>
</li>
<li><a href='crates-and-modules.html'><b>3.2.</b> Crates and Modules</a>
</li>
<li><a href='testing.html'><b>3.3.</b> Testing</a>
</li>
<li><a href='pointers.html'><b>3.4.</b> Pointers</a>
</li>
<li><a href='ownership.html'><b>3.5.</b> Ownership</a>
</li>
<li><a href='patterns.html'><b>3.6.</b> Patterns</a>
</li>
<li><a href='method-syntax.html'><b>3.7.</b> Method Syntax</a>
</li>
<li><a href='closures.html'><b>3.8.</b> Closures</a>
</li>
<li><a href='iterators.html'><b>3.9.</b> Iterators</a>
</li>
<li><a href='generics.html'><b>3.10.</b> Generics</a>
</li>
<li><a href='traits.html'><b>3.11.</b> Traits</a>
</li>
<li><a href='threads.html'><b>3.12.</b> Threads</a>
</li>
<li><a href='error-handling.html'><b>3.13.</b> Error Handling</a>
</li>
<li><a href='documentation.html'><b>3.14.</b> Documentation</a>
</li>
</ul>
</li>
<li><a href='advanced.html'><b>4.</b> III: Advanced Topics</a>
<ul class='section'>
<li><a href='ffi.html'><b>4.1.</b> FFI</a>
</li>
<li><a href='unsafe.html'><b>4.2.</b> Unsafe Code</a>
</li>
<li><a href='macros.html'><b>4.3.</b> Macros</a>
</li>
<li><a href='plugins.html'><b>4.4.</b> Compiler Plugins</a>
</li>
</ul>
</li>
<li><a href='conclusion.html'><b>5.</b> Conclusion</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Macros</h1>
    
<h1 id="introduction" class='section-header'><a
                           href="#introduction">Introduction</a></h1>
<p>Functions are the primary tool that programmers can use to build abstractions.
Sometimes, however, programmers want to abstract over compile-time syntax
rather than run-time values.
Macros provide syntactic abstraction.
For an example of how this can be useful, consider the following two code fragments,
which both pattern-match on their input and both return early in one case,
doing nothing otherwise:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>match</span> <span class='ident'>input_1</span> {
    <span class='ident'>T</span>::<span class='ident'>SpecialA</span>(<span class='ident'>x</span>) <span class='op'>=&gt;</span> { <span class='kw'>return</span> <span class='ident'>x</span>; }
    _ <span class='op'>=&gt;</span> {}
}
<span class='comment'>// ...</span>
<span class='kw'>match</span> <span class='ident'>input_2</span> {
    <span class='ident'>T</span>::<span class='ident'>SpecialB</span>(<span class='ident'>x</span>) <span class='op'>=&gt;</span> { <span class='kw'>return</span> <span class='ident'>x</span>; }
    _ <span class='op'>=&gt;</span> {}
}
</pre>

<p>This code could become tiresome if repeated many times.
However, no function can capture its functionality to make it possible
to abstract the repetition away.
Rust&#39;s macro system, however, can eliminate the repetition. Macros are
lightweight custom syntax extensions, themselves defined using the
<code>macro_rules!</code> syntax extension. The following <code>early_return</code> macro captures
the pattern in the above code:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>early_return</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>inp</span>:<span class='ident'>expr</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>sp</span>:<span class='ident'>path</span>) <span class='op'>=&gt;</span> ( <span class='comment'>// invoke it like `(input_5, SpecialE)`</span>
        <span class='kw'>match</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>inp</span> {
            <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>sp</span>(<span class='ident'>x</span>) <span class='op'>=&gt;</span> { <span class='kw'>return</span> <span class='ident'>x</span>; }
            _ <span class='op'>=&gt;</span> {}
        }
    );
}
<span class='comment'>// ...</span>
<span class='macro'>early_return</span><span class='macro'>!</span>(<span class='ident'>input_1</span>, <span class='ident'>T</span>::<span class='ident'>SpecialA</span>);
<span class='comment'>// ...</span>
<span class='macro'>early_return</span><span class='macro'>!</span>(<span class='ident'>input_2</span>, <span class='ident'>T</span>::<span class='ident'>SpecialB</span>);
</pre>

<p>Macros are defined in pattern-matching style: in the above example, the text
<code>($inp:expr, $sp:path)</code> that appears on the left-hand side of the <code>=&gt;</code> is the
<em>macro invocation syntax</em>, a pattern denoting how to write a call to the
macro. The text on the right-hand side of the <code>=&gt;</code>, beginning with <code>match
$inp</code>, is the <em>macro transcription syntax</em>: what the macro expands to.</p>

<h1 id="invocation-syntax" class='section-header'><a
                           href="#invocation-syntax">Invocation syntax</a></h1>
<p>The macro invocation syntax specifies the syntax for the arguments to the
macro. It appears on the left-hand side of the <code>=&gt;</code> in a macro definition. It
conforms to the following rules:</p>

<ol>
<li>It must be surrounded by parentheses.</li>
<li><code>$</code> has special meaning (described below).</li>
<li>The <code>()</code>s, <code>[]</code>s, and <code>{}</code>s it contains must balance. For example, <code>([)</code> is
forbidden.</li>
<li>Some arguments can be followed only by a limited set of separators, to
avoid ambiguity (described below).</li>
</ol>

<p>Otherwise, the invocation syntax is free-form.</p>

<p>To take a fragment of Rust code as an argument, write <code>$</code> followed by a name
 (for use on the right-hand side), followed by a <code>:</code>, followed by a <em>fragment
 specifier</em>. The fragment specifier denotes the sort of fragment to match. The
 most common fragment specifiers are:</p>

<ul>
<li><code>ident</code> (an identifier, referring to a variable or item. Examples: <code>f</code>, <code>x</code>,
<code>foo</code>.)</li>
<li><code>expr</code> (an expression. Examples: <code>2 + 2</code>; <code>if true then { 1 } else { 2 }</code>;
<code>f(42)</code>.)</li>
<li><code>ty</code> (a type. Examples: <code>i32</code>, <code>Vec&lt;(char, String)&gt;</code>, <code>&amp;T</code>.)</li>
<li><code>path</code> (a path to struct or enum variant. Example: <code>T::SpecialA</code>)</li>
<li><code>pat</code> (a pattern, usually appearing in a <code>match</code> or on the left-hand side of
a declaration. Examples: <code>Some(t)</code>; <code>(17, &#39;a&#39;)</code>; <code>_</code>.)</li>
<li><code>block</code> (a sequence of actions. Example: <code>{ log(error, &quot;hi&quot;); return 12; }</code>)</li>
</ul>

<p>The parser interprets any token that&#39;s not preceded by a <code>$</code> literally. Rust&#39;s usual
rules of tokenization apply,</p>

<p>So <code>($x:ident -&gt; (($e:expr)))</code>, though excessively fancy, would designate a macro
that could be invoked like: <code>my_macro!(i-&gt;(( 2+2 )))</code>.</p>

<p>To avoid ambiguity, macro invocation syntax must conform to the following rules:</p>

<ul>
<li><code>expr</code> must be followed by <code>=&gt;</code>, <code>,</code> or <code>;</code>.</li>
<li><code>ty</code> and <code>path</code> must be followed by <code>=&gt;</code>, <code>,</code>, <code>:</code>, <code>=</code>, <code>&gt;</code> or <code>as</code>.</li>
<li><code>pat</code> must be followed by <code>=&gt;</code>, <code>,</code> or <code>=</code>.</li>
<li><code>ident</code> and <code>block</code> can be followed by any token.</li>
</ul>

<h2 id="invocation-location" class='section-header'><a
                           href="#invocation-location">Invocation location</a></h2>
<p>A macro invocation may take the place of (and therefore expand to) an
expression, item, statement, or pattern.  The Rust parser will parse the macro
invocation as a &quot;placeholder&quot; for whichever syntactic form is appropriate for
the location.</p>

<p>At expansion time, the output of the macro will be parsed as whichever of the
three nonterminals it stands in for. This means that a single macro might,
for example, expand to an item or an expression, depending on its arguments
(and cause a syntax error if it is called with the wrong argument for its
location). Although this behavior sounds excessively dynamic, it is known to
be useful under some circumstances.</p>

<h1 id="transcription-syntax" class='section-header'><a
                           href="#transcription-syntax">Transcription syntax</a></h1>
<p>The right-hand side of the <code>=&gt;</code> follows the same rules as the left-hand side,
except that a <code>$</code> need only be followed by the name of the syntactic fragment
to transcribe into the macro expansion; its type need not be repeated.</p>

<p>The right-hand side must be enclosed by delimiters, which the transcriber ignores.
Therefore <code>() =&gt; ((1,2,3))</code> is a macro that expands to a tuple expression,
<code>() =&gt; (let $x=$val)</code> is a macro that expands to a statement,
and <code>() =&gt; (1,2,3)</code> is a macro that expands to a syntax error
(since the transcriber interprets the parentheses on the right-hand-size as delimiters,
and <code>1,2,3</code> is not a valid Rust expression on its own).</p>

<p>Except for permissibility of <code>$name</code> (and <code>$(...)*</code>, discussed below), the
right-hand side of a macro definition is ordinary Rust syntax. In particular,
macro invocations (including invocations of the macro currently being defined)
are permitted in expression, statement, and item locations. However, nothing
else about the code is examined or executed by the macro system; execution
still has to wait until run-time.</p>

<h2 id="interpolation-location" class='section-header'><a
                           href="#interpolation-location">Interpolation location</a></h2>
<p>The interpolation <code>$argument_name</code> may appear in any location consistent with
its fragment specifier (i.e., if it is specified as <code>ident</code>, it may be used
anywhere an identifier is permitted).</p>

<h1 id="multiplicity" class='section-header'><a
                           href="#multiplicity">Multiplicity</a></h1>
<h2 id="invocation" class='section-header'><a
                           href="#invocation">Invocation</a></h2>
<p>Going back to the motivating example, recall that <code>early_return</code> expanded into
a <code>match</code> that would <code>return</code> if the <code>match</code>&#39;s scrutinee matched the
&quot;special case&quot; identifier provided as the second argument to <code>early_return</code>,
and do nothing otherwise. Now suppose that we wanted to write a
version of <code>early_return</code> that could handle a variable number of &quot;special&quot;
cases.</p>

<p>The syntax <code>$(...)*</code> on the left-hand side of the <code>=&gt;</code> in a macro definition
accepts zero or more occurrences of its contents. It works much
like the <code>*</code> operator in regular expressions. It also supports a
separator token (a comma-separated list could be written <code>$(...),*</code>), and <code>+</code>
instead of <code>*</code> to mean &quot;at least one&quot;.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>early_return</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>inp</span>:<span class='ident'>expr</span>, [ $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>sp</span>:<span class='ident'>path</span>),<span class='op'>+</span> ]) <span class='op'>=&gt;</span> (
        <span class='kw'>match</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>inp</span> {
            $(
                <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>sp</span>(<span class='ident'>x</span>) <span class='op'>=&gt;</span> { <span class='kw'>return</span> <span class='ident'>x</span>; }
            )<span class='op'>+</span>
            _ <span class='op'>=&gt;</span> {}
        }
    )
}
<span class='comment'>// ...</span>
<span class='macro'>early_return</span><span class='macro'>!</span>(<span class='ident'>input_1</span>, [<span class='ident'>T</span>::<span class='ident'>SpecialA</span>,<span class='ident'>T</span>::<span class='ident'>SpecialC</span>,<span class='ident'>T</span>::<span class='ident'>SpecialD</span>]);
<span class='comment'>// ...</span>
<span class='macro'>early_return</span><span class='macro'>!</span>(<span class='ident'>input_2</span>, [<span class='ident'>T</span>::<span class='ident'>SpecialB</span>]);
</pre>

<h3 id="transcription" class='section-header'><a
                           href="#transcription">Transcription</a></h3>
<p>As the above example demonstrates, <code>$(...)*</code> is also valid on the right-hand
side of a macro definition. The behavior of <code>*</code> in transcription,
especially in cases where multiple <code>*</code>s are nested, and multiple different
names are involved, can seem somewhat magical and unintuitive at first. The
system that interprets them is called &quot;Macro By Example&quot;. The two rules to
keep in mind are (1) the behavior of <code>$(...)*</code> is to walk through one &quot;layer&quot;
of repetitions for all of the <code>$name</code>s it contains in lockstep, and (2) each
<code>$name</code> must be under at least as many <code>$(...)*</code>s as it was matched against.
If it is under more, it&#39;ll be repeated, as appropriate.</p>

<h2 id="parsing-limitations" class='section-header'><a
                           href="#parsing-limitations">Parsing limitations</a></h2>
<p>For technical reasons, there are two limitations to the treatment of syntax
fragments by the macro parser:</p>

<ol>
<li>The parser will always parse as much as possible of a Rust syntactic
fragment. For example, if the comma were omitted from the syntax of
<code>early_return!</code> above, <code>input_1 [</code> would&#39;ve been interpreted as the beginning
of an array index. In fact, invoking the macro would have been impossible.</li>
<li>The parser must have eliminated all ambiguity by the time it reaches a
<code>$name:fragment_specifier</code> declaration. This limitation can result in parse
errors when declarations occur at the beginning of, or immediately after,
a <code>$(...)*</code>. For example, the grammar <code>$($t:ty)* $e:expr</code> will always fail to
parse because the parser would be forced to choose between parsing <code>t</code> and
parsing <code>e</code>. Changing the invocation syntax to require a distinctive token in
front can solve the problem. In the above example, <code>$(T $t:ty)* E $e:exp</code>
solves the problem.</li>
</ol>

<h1 id="macro-argument-pattern-matching" class='section-header'><a
                           href="#macro-argument-pattern-matching">Macro argument pattern matching</a></h1>
<h2 id="motivation" class='section-header'><a
                           href="#motivation">Motivation</a></h2>
<p>Now consider code like the following:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>match</span> <span class='ident'>x</span> {
    <span class='ident'>T1</span>::<span class='ident'>Good1</span>(<span class='ident'>g1</span>, <span class='ident'>val</span>) <span class='op'>=&gt;</span> {
        <span class='kw'>match</span> <span class='ident'>g1</span>.<span class='ident'>body</span> {
            <span class='ident'>T3</span>::<span class='ident'>Good2</span>(<span class='ident'>result</span>) <span class='op'>=&gt;</span> {
                <span class='comment'>// complicated stuff goes here</span>
                <span class='kw'>return</span> <span class='ident'>result</span> <span class='op'>+</span> <span class='ident'>val</span>;
            },
            _ <span class='op'>=&gt;</span> <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;Didn&#39;t get good_2&quot;</span>)
        }
    }
    _ <span class='op'>=&gt;</span> <span class='kw'>return</span> <span class='number'>0</span> <span class='comment'>// default value</span>
}
</pre>

<p>All the complicated stuff is deeply indented, and the error-handling code is
separated from matches that fail. We&#39;d like to write a macro that performs
a match, but with a syntax that suits the problem better. The following macro
can solve the problem:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>biased_match</span> {
    <span class='comment'>// special case: `let (x) = ...` is illegal, so use `let x = ...` instead</span>
    ( (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>-&gt;</span> (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span>:<span class='ident'>pat</span>) <span class='kw'>else</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>err</span>:<span class='ident'>stmt</span> ;
      <span class='ident'>binds</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>bind_res</span>:<span class='ident'>ident</span>
    ) <span class='op'>=&gt;</span> (
        <span class='kw'>let</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>bind_res</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span> {
            <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span> <span class='op'>=&gt;</span> ( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>bind_res</span> ),
            _ <span class='op'>=&gt;</span> { <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>err</span> }
        };
    );
    <span class='comment'>// more than one name; use a tuple</span>
    ( (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>-&gt;</span> (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span>:<span class='ident'>pat</span>) <span class='kw'>else</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>err</span>:<span class='ident'>stmt</span> ;
      <span class='ident'>binds</span> $( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>bind_res</span>:<span class='ident'>ident</span> ),<span class='op'>*</span>
    ) <span class='op'>=&gt;</span> (
        <span class='kw'>let</span> ( $( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>bind_res</span> ),<span class='op'>*</span> ) <span class='op'>=</span> <span class='kw'>match</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span> {
            <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span> <span class='op'>=&gt;</span> ( $( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>bind_res</span> ),<span class='op'>*</span> ),
            _ <span class='op'>=&gt;</span> { <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>err</span> }
        };
    )
}

<span class='macro'>biased_match</span><span class='macro'>!</span>((<span class='ident'>x</span>)       <span class='op'>-&gt;</span> (<span class='ident'>T1</span>::<span class='ident'>Good1</span>(<span class='ident'>g1</span>, <span class='ident'>val</span>)) <span class='kw'>else</span> { <span class='kw'>return</span> <span class='number'>0</span> };
              <span class='ident'>binds</span> <span class='ident'>g1</span>, <span class='ident'>val</span> );
<span class='macro'>biased_match</span><span class='macro'>!</span>((<span class='ident'>g1</span>.<span class='ident'>body</span>) <span class='op'>-&gt;</span> (<span class='ident'>T3</span>::<span class='ident'>Good2</span>(<span class='ident'>result</span>) )
                  <span class='kw'>else</span> { <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;Didn&#39;t get good_2&quot;</span>) };
              <span class='ident'>binds</span> <span class='ident'>result</span> );
<span class='comment'>// complicated stuff goes here</span>
<span class='kw'>return</span> <span class='ident'>result</span> <span class='op'>+</span> <span class='ident'>val</span>;
</pre>

<p>This solves the indentation problem. But if we have a lot of chained matches
like this, we might prefer to write a single macro invocation. The input
pattern we want is clear:</p>
<pre id='rust-example-rendered' class='rust '>
    ( $( (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>-&gt;</span> (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span>:<span class='ident'>pat</span>) <span class='kw'>else</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>err</span>:<span class='ident'>stmt</span> ; )<span class='op'>*</span>
      <span class='ident'>binds</span> $( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>bind_res</span>:<span class='ident'>ident</span> ),<span class='op'>*</span>
    )
</pre>

<p>However, it&#39;s not possible to directly expand to nested match statements. But
there is a solution.</p>

<h2 id="the-recursive-approach-to-macro-writing" class='section-header'><a
                           href="#the-recursive-approach-to-macro-writing">The recursive approach to macro writing</a></h2>
<p>A macro may accept multiple different input grammars. The first one to
successfully match the actual argument to a macro invocation is the one that
&quot;wins&quot;.</p>

<p>In the case of the example above, we want to write a recursive macro to
process the semicolon-terminated lines, one-by-one. So, we want the following
input patterns:</p>
<pre id='rust-example-rendered' class='rust '>
    ( <span class='ident'>binds</span> $( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>bind_res</span>:<span class='ident'>ident</span> ),<span class='op'>*</span> )
</pre>

<p>...and:</p>
<pre id='rust-example-rendered' class='rust '>
    (    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>     :<span class='ident'>expr</span>) <span class='op'>-&gt;</span> (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span>     :<span class='ident'>pat</span>) <span class='kw'>else</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>err</span>     :<span class='ident'>stmt</span> ;
      $( (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e_rest</span>:<span class='ident'>expr</span>) <span class='op'>-&gt;</span> (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p_rest</span>:<span class='ident'>pat</span>) <span class='kw'>else</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>err_rest</span>:<span class='ident'>stmt</span> ; )<span class='op'>*</span>
      <span class='ident'>binds</span>  $( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>bind_res</span>:<span class='ident'>ident</span> ),<span class='op'>*</span>
    )
</pre>

<p>The resulting macro looks like this. Note that the separation into
<code>biased_match!</code> and <code>biased_match_rec!</code> occurs only because we have an outer
piece of syntax (the <code>let</code>) which we only want to transcribe once.</p>
<pre id='rust-example-rendered' class='rust '>

<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>biased_match_rec</span> {
    <span class='comment'>// Handle the first layer</span>
    (   (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>     :<span class='ident'>expr</span>) <span class='op'>-&gt;</span> (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span>     :<span class='ident'>pat</span>) <span class='kw'>else</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>err</span>     :<span class='ident'>stmt</span> ;
     $( (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e_rest</span>:<span class='ident'>expr</span>) <span class='op'>-&gt;</span> (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p_rest</span>:<span class='ident'>pat</span>) <span class='kw'>else</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>err_rest</span>:<span class='ident'>stmt</span> ; )<span class='op'>*</span>
     <span class='ident'>binds</span> $( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>bind_res</span>:<span class='ident'>ident</span> ),<span class='op'>*</span>
    ) <span class='op'>=&gt;</span> (
        <span class='kw'>match</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span> {
            <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span> <span class='op'>=&gt;</span> {
                <span class='comment'>// Recursively handle the next layer</span>
                <span class='macro'>biased_match_rec</span><span class='macro'>!</span>($( (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e_rest</span>) <span class='op'>-&gt;</span> (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p_rest</span>) <span class='kw'>else</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>err_rest</span> ; )<span class='op'>*</span>
                                  <span class='ident'>binds</span> $( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>bind_res</span> ),<span class='op'>*</span>
                )
            }
            _ <span class='op'>=&gt;</span> { <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>err</span> }
        }
    );
    <span class='comment'>// Produce the requested values</span>
    ( <span class='ident'>binds</span> $( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>bind_res</span>:<span class='ident'>ident</span> ),<span class='op'>*</span> ) <span class='op'>=&gt;</span> ( ($( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>bind_res</span> ),<span class='op'>*</span>) )
}

<span class='comment'>// Wrap the whole thing in a `let`.</span>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>biased_match</span> {
    <span class='comment'>// special case: `let (x) = ...` is illegal, so use `let x = ...` instead</span>
    ( $( (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>-&gt;</span> (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span>:<span class='ident'>pat</span>) <span class='kw'>else</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>err</span>:<span class='ident'>stmt</span> ; )<span class='op'>*</span>
      <span class='ident'>binds</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>bind_res</span>:<span class='ident'>ident</span>
    ) <span class='op'>=&gt;</span> (
        <span class='kw'>let</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>bind_res</span> <span class='op'>=</span> <span class='macro'>biased_match_rec</span><span class='macro'>!</span>(
            $( (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>) <span class='op'>-&gt;</span> (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span>) <span class='kw'>else</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>err</span> ; )<span class='op'>*</span>
            <span class='ident'>binds</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>bind_res</span>
        );
    );
    <span class='comment'>// more than one name: use a tuple</span>
    ( $( (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>-&gt;</span> (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span>:<span class='ident'>pat</span>) <span class='kw'>else</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>err</span>:<span class='ident'>stmt</span> ; )<span class='op'>*</span>
      <span class='ident'>binds</span>  $( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>bind_res</span>:<span class='ident'>ident</span> ),<span class='op'>*</span>
    ) <span class='op'>=&gt;</span> (
        <span class='kw'>let</span> ( $( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>bind_res</span> ),<span class='op'>*</span> ) <span class='op'>=</span> <span class='macro'>biased_match_rec</span><span class='macro'>!</span>(
            $( (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>) <span class='op'>-&gt;</span> (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span>) <span class='kw'>else</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>err</span> ; )<span class='op'>*</span>
            <span class='ident'>binds</span> $( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>bind_res</span> ),<span class='op'>*</span>
        );
    )
}


<span class='macro'>biased_match</span><span class='macro'>!</span>(
    (<span class='ident'>x</span>)       <span class='op'>-&gt;</span> (<span class='ident'>T1</span>::<span class='ident'>Good1</span>(<span class='ident'>g1</span>, <span class='ident'>val</span>)) <span class='kw'>else</span> { <span class='kw'>return</span> <span class='number'>0</span> };
    (<span class='ident'>g1</span>.<span class='ident'>body</span>) <span class='op'>-&gt;</span> (<span class='ident'>T3</span>::<span class='ident'>Good2</span>(<span class='ident'>result</span>) ) <span class='kw'>else</span> { <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;Didn&#39;t get Good2&quot;</span>) };
    <span class='ident'>binds</span> <span class='ident'>val</span>, <span class='ident'>result</span> );
<span class='comment'>// complicated stuff goes here</span>
<span class='kw'>return</span> <span class='ident'>result</span> <span class='op'>+</span> <span class='ident'>val</span>;
</pre>

<p>This technique applies to many cases where transcribing a result all at once is not possible.
The resulting code resembles ordinary functional programming in some respects,
but has some important differences from functional programming.</p>

<p>The first difference is important, but also easy to forget: the transcription
(right-hand) side of a <code>macro_rules!</code> rule is literal syntax, which can only
be executed at run-time. If a piece of transcription syntax does not itself
appear inside another macro invocation, it will become part of the final
program. If it is inside a macro invocation (for example, the recursive
invocation of <code>biased_match_rec!</code>), it does have the opportunity to affect
transcription, but only through the process of attempted pattern matching.</p>

<p>The second, related, difference is that the evaluation order of macros feels
&quot;backwards&quot; compared to ordinary programming. Given an invocation
<code>m1!(m2!())</code>, the expander first expands <code>m1!</code>, giving it as input the literal
syntax <code>m2!()</code>. If it transcribes its argument unchanged into an appropriate
position (in particular, not as an argument to yet another macro invocation),
the expander will then proceed to evaluate <code>m2!()</code> (along with any other macro
invocations <code>m1!(m2!())</code> produced).</p>

<h1 id="hygiene" class='section-header'><a
                           href="#hygiene">Hygiene</a></h1>
<p>To prevent clashes, rust implements
<a href="http://en.wikipedia.org/wiki/Hygienic_macro">hygienic macros</a>.</p>

<p>As an example, <code>loop</code> and <code>for-loop</code> labels (discussed in the lifetimes guide)
will not clash. The following code will print &quot;Hello!&quot; only once:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>loop_x</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>: <span class='ident'>expr</span>) <span class='op'>=&gt;</span> (
        <span class='comment'>// $e will not interact with this &#39;x</span>
        <span class='lifetime'>&#39;x</span>: <span class='kw'>loop</span> {
            <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello!&quot;</span>);
            <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>
        }
    );
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='lifetime'>&#39;x</span>: <span class='kw'>loop</span> {
        <span class='macro'>loop_x</span><span class='macro'>!</span>(<span class='kw'>break</span> <span class='lifetime'>&#39;x</span>);
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;I am never printed.&quot;</span>);
    }
}
</pre>

<p>The two <code>&#39;x</code> names did not clash, which would have caused the loop
to print &quot;I am never printed&quot; and to run forever.</p>

<h1 id="scoping-and-macro-import/export" class='section-header'><a
                           href="#scoping-and-macro-import/export">Scoping and macro import/export</a></h1>
<p>Macros are expanded at an early stage in compilation, before name resolution.
One downside is that scoping works differently for macros, compared to other
constructs in the language.</p>

<p>Definition and expansion of macros both happen in a single depth-first,
lexical-order traversal of a crate&#39;s source. So a macro defined at module scope
is visible to any subsequent code in the same module, which includes the body
of any subsequent child <code>mod</code> items.</p>

<p>A macro defined within the body of a single <code>fn</code>, or anywhere else not at
module scope, is visible only within that item.</p>

<p>If a module has the <code>macro_use</code> attribute, its macros are also visible in its
parent module after the child&#39;s <code>mod</code> item. If the parent also has <code>macro_use</code>
then the macros will be visible in the grandparent after the parent&#39;s <code>mod</code>
item, and so forth.</p>

<p>The <code>macro_use</code> attribute can also appear on <code>extern crate</code>.  In this context
it controls which macros are loaded from the external crate, e.g.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='attribute'>#[<span class='ident'>macro_use</span>(<span class='ident'>foo</span>, <span class='ident'>bar</span>)]</span>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>baz</span>;
</pre>

<p>If the attribute is given simply as <code>#[macro_use]</code>, all macros are loaded.  If
there is no <code>#[macro_use]</code> attribute then no macros are loaded.  Only macros
defined with the <code>#[macro_export]</code> attribute may be loaded.</p>

<p>To load a crate&#39;s macros <em>without</em> linking it into the output, use <code>#[no_link]</code>
as well.</p>

<p>An example:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>m1</span> { () <span class='op'>=&gt;</span> (()) }

<span class='comment'>// visible here: m1</span>

<span class='kw'>mod</span> <span class='ident'>foo</span> {
    <span class='comment'>// visible here: m1</span>

    <span class='attribute'>#[<span class='ident'>macro_export</span>]</span>
    <span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>m2</span> { () <span class='op'>=&gt;</span> (()) }

    <span class='comment'>// visible here: m1, m2</span>
}

<span class='comment'>// visible here: m1</span>

<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>m3</span> { () <span class='op'>=&gt;</span> (()) }

<span class='comment'>// visible here: m1, m3</span>

<span class='attribute'>#[<span class='ident'>macro_use</span>]</span>
<span class='kw'>mod</span> <span class='ident'>bar</span> {
    <span class='comment'>// visible here: m1, m3</span>

    <span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>m4</span> { () <span class='op'>=&gt;</span> (()) }

    <span class='comment'>// visible here: m1, m3, m4</span>
}

<span class='comment'>// visible here: m1, m3, m4</span>
</pre>

<p>When this library is loaded with <code>#[use_macros] extern crate</code>, only <code>m2</code> will
be imported.</p>

<p>The Rust Reference has a <a href="../reference.html#macro--and-plugin-related-attributes">listing of macro-related
attributes</a>.</p>

<h1 id="the-variable-$crate" class='section-header'><a
                           href="#the-variable-$crate">The variable <code>$crate</code></a></h1>
<p>A further difficulty occurs when a macro is used in multiple crates.  Say that
<code>mylib</code> defines</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>increment</span>(<span class='ident'>x</span>: <span class='ident'>u32</span>) <span class='op'>-&gt;</span> <span class='ident'>u32</span> {
    <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>
}

<span class='attribute'>#[<span class='ident'>macro_export</span>]</span>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>inc_a</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> ( ::<span class='ident'>increment</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>) )
}

<span class='attribute'>#[<span class='ident'>macro_export</span>]</span>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>inc_b</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> ( ::<span class='ident'>mylib</span>::<span class='ident'>increment</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>) )
}
</pre>

<p><code>inc_a</code> only works within <code>mylib</code>, while <code>inc_b</code> only works outside the
library.  Furthermore, <code>inc_b</code> will break if the user imports <code>mylib</code> under
another name.</p>

<p>Rust does not (yet) have a hygiene system for crate references, but it does
provide a simple workaround for this problem.  Within a macro imported from a
crate named <code>foo</code>, the special macro variable <code>$crate</code> will expand to <code>::foo</code>.
By contrast, when a macro is defined and then used in the same crate, <code>$crate</code>
will expand to nothing.  This means we can write</p>
<pre id='rust-example-rendered' class='rust '>
<span class='attribute'>#[<span class='ident'>macro_export</span>]</span>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>inc</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> ( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>crate</span>::<span class='ident'>increment</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>) )
}
</pre>

<p>to define a single macro that works both inside and outside our library.  The
function name will expand to either <code>::increment</code> or <code>::mylib::increment</code>.</p>

<p>To keep this system simple and correct, <code>#[macro_use] extern crate ...</code> may
only appear at the root of your crate, not inside <code>mod</code>.  This ensures that
<code>$crate</code> is a single identifier.</p>

<h1 id="a-final-note" class='section-header'><a
                           href="#a-final-note">A final note</a></h1>
<p>Macros, as currently implemented, are not for the faint of heart. Even
ordinary syntax errors can be more difficult to debug when they occur inside a
macro, and errors caused by parse problems in generated code can be very
tricky. Invoking the <code>log_syntax!</code> macro can help elucidate intermediate
states, invoking <code>trace_macros!(true)</code> will automatically print those
intermediate states out, and passing the flag <code>--pretty expanded</code> as a
command-line argument to the compiler will show the result of expansion.</p>

<p>If Rust&#39;s macro system can&#39;t do what you need, you may want to write a
<a href="plugins.html">compiler plugin</a> instead. Compared to <code>macro_rules!</code>
macros, this is significantly more work, the interfaces are much less stable,
and the warnings about debugging apply ten-fold. In exchange you get the
flexibility of running arbitrary Rust code within the compiler. Syntax
extension plugins are sometimes called <em>procedural macros</em> for this reason.</p>

    <script type="text/javascript">
        window.playgroundUrl = "";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceeding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
</div></div>


</body>
</html>