<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `collections` mod in crate `std`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, collections">

    <title>std::collections - Rust</title>

    <link rel="stylesheet" type="text/css" href="../../main.css">

    <link rel="shortcut icon" href="http://www.rust-lang.org/favicon.ico">
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <section class="sidebar">
        <a href='../../std/index.html'><img src='http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt='' width='100'></a>
        <p class='location'><a href='../index.html'>std</a></p><div class='block mod'><h2>Modules</h2><a class='mod ' href='../any/index.html' title='Traits for dynamic typing of any `&#39;static` type (through runtime reflection)'>any</a><a class='mod ' href='../ascii/index.html' title='Operations on ASCII strings and characters'>ascii</a><a class='mod ' href='../borrow/index.html' title='A module for working with borrowed data.'>borrow</a><a class='mod ' href='../boxed/index.html' title='A pointer type for heap allocation.'>boxed</a><a class='mod ' href='../cell/index.html' title='Shareable mutable containers.'>cell</a><a class='mod ' href='../char/index.html' title='Character manipulation (`char` type, Unicode Scalar Value)'>char</a><a class='mod ' href='../clone/index.html' title='The `Clone` trait for types that cannot be &#39;implicitly copied&#39;'>clone</a><a class='mod ' href='../cmp/index.html' title='Defines the `PartialOrd` and `PartialEq` comparison traits.'>cmp</a><a class='mod current' href='../collections/index.html' title='Collection types.'>collections</a><a class='mod ' href='../default/index.html' title='The `Default` trait for types which may have meaningful default values.'>default</a><a class='mod ' href='../dynamic_lib/index.html' title='Dynamic library facilities.'>dynamic_lib</a><a class='mod ' href='../env/index.html' title='Inspection and manipulation of the process&#39;s environment.'>env</a><a class='mod ' href='../error/index.html' title='Traits for working with Errors.'>error</a><a class='mod ' href='../f32/index.html' title='Operations and constants for 32-bits floats (`f32` type)'>f32</a><a class='mod ' href='../f64/index.html' title='Operations and constants for 64-bits floats (`f64` type)'>f64</a><a class='mod ' href='../ffi/index.html' title='Utilities related to FFI bindings.'>ffi</a><a class='mod ' href='../finally/index.html' title='The Finally trait provides a method, `finally` on stack closures that emulates Java-style try/finally blocks.'>finally</a><a class='mod ' href='../fmt/index.html' title='Utilities for formatting and printing strings'>fmt</a><a class='mod ' href='../hash/index.html' title='Generic hashing support.'>hash</a><a class='mod ' href='../i16/index.html' title='Operations and constants for signed 16-bits integers (`i16` type)'>i16</a><a class='mod ' href='../i32/index.html' title='Operations and constants for signed 32-bits integers (`i32` type)'>i32</a><a class='mod ' href='../i64/index.html' title='Operations and constants for signed 64-bits integers (`i64` type)'>i64</a><a class='mod ' href='../i8/index.html' title='Operations and constants for signed 8-bits integers (`i8` type)'>i8</a><a class='mod ' href='../int/index.html' title='Deprecated: replaced by `isize`.'>int</a><a class='mod ' href='../intrinsics/index.html' title='rustc compiler intrinsics.'>intrinsics</a><a class='mod ' href='../isize/index.html' title='Operations and constants for pointer-sized signed integers (`isize` type)'>isize</a><a class='mod ' href='../iter/index.html' title='Composable external iterators'>iter</a><a class='mod ' href='../marker/index.html' title='Primitive traits and marker types representing basic &#39;kinds&#39; of types.'>marker</a><a class='mod ' href='../mem/index.html' title='Basic functions for dealing with memory'>mem</a><a class='mod ' href='../num/index.html' title='Numeric traits and functions for generic mathematics'>num</a><a class='mod ' href='../old_io/index.html' title='I/O, including files, networking, timers, and processes'>old_io</a><a class='mod ' href='../ops/index.html' title='Overloadable operators'>ops</a><a class='mod ' href='../option/index.html' title='Optional values'>option</a><a class='mod ' href='../os/index.html' title='Higher-level interfaces to libc::* functions and operating system services.'>os</a><a class='mod ' href='../path/index.html' title='Cross-platform path support'>path</a><a class='mod ' href='../prelude/index.html' title='The Rust prelude'>prelude</a><a class='mod ' href='../ptr/index.html' title='Operations on unsafe pointers, `*const T`, and `*mut T`.'>ptr</a><a class='mod ' href='../rand/index.html' title='Utilities for random number generation'>rand</a><a class='mod ' href='../raw/index.html' title='Contains struct definitions for the layout of compiler built-in types.'>raw</a><a class='mod ' href='../rc/index.html' title='Thread-local reference-counted boxes (the `Rc&lt;T&gt;` type).'>rc</a><a class='mod ' href='../result/index.html' title='Error handling with the `Result` type'>result</a><a class='mod ' href='../rt/index.html' title='Runtime services'>rt</a><a class='mod ' href='../simd/index.html' title='SIMD vectors.'>simd</a><a class='mod ' href='../slice/index.html' title='Utilities for slice manipulation'>slice</a><a class='mod ' href='../str/index.html' title='Unicode string manipulation (`str` type)'>str</a><a class='mod ' href='../string/index.html' title='An owned, growable string that enforces that its contents are valid UTF-8.'>string</a><a class='mod ' href='../sync/index.html' title='Useful synchronization primitives'>sync</a><a class='mod ' href='../thread/index.html' title='Native threads'>thread</a><a class='mod ' href='../thread_local/index.html' title='Thread local storage'>thread_local</a><a class='mod ' href='../thunk/index.html' title=''>thunk</a><a class='mod ' href='../time/index.html' title='Temporal quantification.'>time</a><a class='mod ' href='../u16/index.html' title='Operations and constants for unsigned 16-bits integers (`u16` type)'>u16</a><a class='mod ' href='../u32/index.html' title='Operations and constants for unsigned 32-bits integers (`u32` type)'>u32</a><a class='mod ' href='../u64/index.html' title='Operations and constants for unsigned 64-bits integer (`u64` type)'>u64</a><a class='mod ' href='../u8/index.html' title='Operations and constants for unsigned 8-bits integers (`u8` type)'>u8</a><a class='mod ' href='../uint/index.html' title='Deprecated: replaced by `usize`.'>uint</a><a class='mod ' href='../usize/index.html' title='Operations and constants for pointer-sized unsigned integers (`usize` type)'>usize</a><a class='mod ' href='../vec/index.html' title='A growable list type with heap-allocated contents, written `Vec&lt;T&gt;` but pronounced &#39;vector.&#39;'>vec</a></div><div class='block macro'><h2>Macros</h2><a class='macro ' href='../macro.assert!.html' title='Ensure that a boolean expression is `true` at runtime.'>assert!</a><a class='macro ' href='../macro.assert_eq!.html' title='Asserts that two expressions are equal to each other, testing equality in both directions.'>assert_eq!</a><a class='macro ' href='../macro.cfg!.html' title='Boolean evaluation of configuration flags.'>cfg!</a><a class='macro ' href='../macro.column!.html' title='A macro which expands to the column number on which it was invoked.'>column!</a><a class='macro ' href='../macro.concat!.html' title='Concatenates literals into a static string slice.'>concat!</a><a class='macro ' href='../macro.concat_idents!.html' title='Concatenate identifiers into one identifier.'>concat_idents!</a><a class='macro ' href='../macro.debug_assert!.html' title='Ensure that a boolean expression is `true` at runtime.'>debug_assert!</a><a class='macro ' href='../macro.debug_assert_eq!.html' title='Asserts that two expressions are equal to each other, testing equality in both directions.'>debug_assert_eq!</a><a class='macro ' href='../macro.env!.html' title='Inspect an environment variable at compile time.'>env!</a><a class='macro ' href='../macro.file!.html' title='A macro which expands to the file name from which it was invoked.'>file!</a><a class='macro ' href='../macro.format!.html' title='Use the syntax described in `std::fmt` to create a value of type `String`. See `std::fmt` for more information.'>format!</a><a class='macro ' href='../macro.format_args!.html' title='The core macro for formatted string creation &amp; output.'>format_args!</a><a class='macro ' href='../macro.include_bytes!.html' title='Includes a file as a byte slice.'>include_bytes!</a><a class='macro ' href='../macro.include_str!.html' title='Includes a utf8-encoded file as a string.'>include_str!</a><a class='macro ' href='../macro.line!.html' title='A macro which expands to the line number on which it was invoked.'>line!</a><a class='macro ' href='../macro.module_path!.html' title='Expands to a string that represents the current module path.'>module_path!</a><a class='macro ' href='../macro.option_env!.html' title='Optionally inspect an environment variable at compile time.'>option_env!</a><a class='macro ' href='../macro.panic!.html' title='The entry point for panic of Rust tasks.'>panic!</a><a class='macro ' href='../macro.print!.html' title='Equivalent to the `println!` macro except that a newline is not printed at the end of the message.'>print!</a><a class='macro ' href='../macro.println!.html' title='Macro for printing to a task&#39;s stdout handle.'>println!</a><a class='macro ' href='../macro.scoped_thread_local!.html' title='Declare a new scoped thread local storage key.'>scoped_thread_local!</a><a class='macro ' href='../macro.select!.html' title='A macro to select an event from a number of receivers.'>select!</a><a class='macro ' href='../macro.stringify!.html' title='A macro which stringifies its argument.'>stringify!</a><a class='macro ' href='../macro.thread_local!.html' title='Declare a new thread local storage key of type `std::thread_local::Key`.'>thread_local!</a><a class='macro ' href='../macro.try!.html' title='Helper macro for unwrapping `Result` values while returning early with an error if the value of the expression is `Err`. For more information, see `std::io`.'>try!</a><a class='macro ' href='../macro.unimplemented!.html' title='A standardised placeholder for marking unfinished code. It panics with the message `&quot;not yet implemented&quot;` when executed.'>unimplemented!</a><a class='macro ' href='../macro.unreachable!.html' title='A utility macro for indicating unreachable code.'>unreachable!</a><a class='macro ' href='../macro.vec!.html' title='Creates a `Vec` containing the arguments.'>vec!</a><a class='macro ' href='../macro.write!.html' title='Use the `format!` syntax to write data into a buffer of type `&amp;mut Writer`. See `std::fmt` for more information.'>write!</a><a class='macro ' href='../macro.writeln!.html' title='Equivalent to the `write!` macro, except that a newline is appended after the message is written.'>writeln!</a></div>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press 'S' to search, '?' for more options..."
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content mod">
<h1 class='fqn'><span class='in-band'>Module <a href='../index.html'>std</a>::<wbr><a class='mod' href=''>collections</a><wbr><a class='stability Stable' title=''>Stable</a></span><span class='out-of-band'><span id='render-detail'>
            <a id="collapse-all" href="#">[-]
            </a>&nbsp;<a id="expand-all" href="#">[+]</a>
        </span><a id='src-52651' href='../../src/std/collections/mod.rs.html#11-393'>[src]</a></span></h1>
<div class='docblock'><p>Collection types.</p>

<p>Rust&#39;s standard collection library provides efficient implementations of the most common
general purpose programming data structures. By using the standard implementations,
it should be possible for two libraries to communicate without significant data conversion.</p>

<p>To get this out of the way: you should probably just use <code>Vec</code> or <code>HashMap</code>. These two
collections cover most use cases for generic data storage and processing. They are
exceptionally good at doing what they do. All the other collections in the standard
library have specific use cases where they are the optimal choice, but these cases are
borderline <em>niche</em> in comparison. Even when <code>Vec</code> and <code>HashMap</code> are technically suboptimal,
they&#39;re probably a good enough choice to get started.</p>

<p>Rust&#39;s collections can be grouped into four major categories:</p>

<ul>
<li>Sequences: <code>Vec</code>, <code>RingBuf</code>, <code>DList</code>, <code>BitV</code></li>
<li>Maps: <code>HashMap</code>, <code>BTreeMap</code>, <code>VecMap</code></li>
<li>Sets: <code>HashSet</code>, <code>BTreeSet</code>, <code>BitVSet</code></li>
<li>Misc: <code>BinaryHeap</code></li>
</ul>

<h1 id="when-should-you-use-which-collection?" class='section-header'><a
                           href="#when-should-you-use-which-collection?">When Should You Use Which Collection?</a></h1>
<p>These are fairly high-level and quick break-downs of when each collection should be
considered. Detailed discussions of strengths and weaknesses of individual collections
can be found on their own documentation pages.</p>

<h3 id="use-a-vec-when:" class='section-header'><a
                           href="#use-a-vec-when:">Use a <code>Vec</code> when:</a></h3>
<ul>
<li>You want to collect items up to be processed or sent elsewhere later, and don&#39;t care about
any properties of the actual values being stored.</li>
<li>You want a sequence of elements in a particular order, and will only be appending to
(or near) the end.</li>
<li>You want a stack.</li>
<li>You want a resizable array.</li>
<li>You want a heap-allocated array.</li>
</ul>

<h3 id="use-a-ringbuf-when:" class='section-header'><a
                           href="#use-a-ringbuf-when:">Use a <code>RingBuf</code> when:</a></h3>
<ul>
<li>You want a <code>Vec</code> that supports efficient insertion at both ends of the sequence.</li>
<li>You want a queue.</li>
<li>You want a double-ended queue (deque).</li>
</ul>

<h3 id="use-a-dlist-when:" class='section-header'><a
                           href="#use-a-dlist-when:">Use a <code>DList</code> when:</a></h3>
<ul>
<li>You want a <code>Vec</code> or <code>RingBuf</code> of unknown size, and can&#39;t tolerate amortization.</li>
<li>You want to efficiently split and append lists.</li>
<li>You are <em>absolutely</em> certain you <em>really</em>, <em>truly</em>, want a doubly linked list.</li>
</ul>

<h3 id="use-a-hashmap-when:" class='section-header'><a
                           href="#use-a-hashmap-when:">Use a <code>HashMap</code> when:</a></h3>
<ul>
<li>You want to associate arbitrary keys with an arbitrary value.</li>
<li>You want a cache.</li>
<li>You want a map, with no extra functionality.</li>
</ul>

<h3 id="use-a-btreemap-when:" class='section-header'><a
                           href="#use-a-btreemap-when:">Use a <code>BTreeMap</code> when:</a></h3>
<ul>
<li>You&#39;re interested in what the smallest or largest key-value pair is.</li>
<li>You want to find the largest or smallest key that is smaller or larger than something</li>
<li>You want to be able to get all of the entries in order on-demand.</li>
<li>You want a sorted map.</li>
</ul>

<h3 id="use-a-vecmap-when:" class='section-header'><a
                           href="#use-a-vecmap-when:">Use a <code>VecMap</code> when:</a></h3>
<ul>
<li>You want a <code>HashMap</code> but with known to be small <code>uint</code> keys.</li>
<li>You want a <code>BTreeMap</code>, but with known to be small <code>uint</code> keys.</li>
</ul>

<h3 id="use-the-set-variant-of-any-of-these-maps-when:" class='section-header'><a
                           href="#use-the-set-variant-of-any-of-these-maps-when:">Use the <code>Set</code> variant of any of these <code>Map</code>s when:</a></h3>
<ul>
<li>You just want to remember which keys you&#39;ve seen.</li>
<li>There is no meaningful value to associate with your keys.</li>
<li>You just want a set.</li>
</ul>

<h3 id="use-a-bitv-when:" class='section-header'><a
                           href="#use-a-bitv-when:">Use a <code>BitV</code> when:</a></h3>
<ul>
<li>You want to store an unbounded number of booleans in a small space.</li>
<li>You want a bitvector.</li>
</ul>

<h3 id="use-a-bitvset-when:" class='section-header'><a
                           href="#use-a-bitvset-when:">Use a <code>BitVSet</code> when:</a></h3>
<ul>
<li>You want a <code>VecSet</code>.</li>
</ul>

<h3 id="use-a-binaryheap-when:" class='section-header'><a
                           href="#use-a-binaryheap-when:">Use a <code>BinaryHeap</code> when:</a></h3>
<ul>
<li>You want to store a bunch of elements, but only ever want to process the &quot;biggest&quot;
or &quot;most important&quot; one at any given time.</li>
<li>You want a priority queue.</li>
</ul>

<h1 id="performance" class='section-header'><a
                           href="#performance">Performance</a></h1>
<p>Choosing the right collection for the job requires an understanding of what each collection
is good at. Here we briefly summarize the performance of different collections for certain
important operations. For further details, see each type&#39;s documentation.</p>

<p>Throughout the documentation, we will follow a few conventions. For all operations,
the collection&#39;s size is denoted by n. If another collection is involved in the operation, it
contains m elements. Operations which have an <em>amortized</em> cost are suffixed with a <code>*</code>.
Operations with an <em>expected</em> cost are suffixed with a <code>~</code>.</p>

<p>All amortized costs are for the potential need to resize when capacity is exhausted.
If a resize occurs it will take O(n) time. Our collections never automatically shrink,
so removal operations aren&#39;t amortized. Over a sufficiently large series of
operations, the average cost per operation will deterministically equal the given cost.</p>

<p>Only HashMap has expected costs, due to the probabilistic nature of hashing. It is
theoretically possible, though very unlikely, for HashMap to experience worse performance.</p>

<h2 id="sequences" class='section-header'><a
                           href="#sequences">Sequences</a></h2>
<table><thead>
<tr>
<th></th>
<th>get(i)</th>
<th>insert(i)</th>
<th>remove(i)</th>
<th>append</th>
<th>split_off(i)</th>
</tr>
</thead><tbody>
<tr>
<td>Vec</td>
<td>O(1)</td>
<td>O(n-i)*</td>
<td>O(n-i)</td>
<td>O(m)*</td>
<td>O(n-i)</td>
</tr>
<tr>
<td>RingBuf</td>
<td>O(1)</td>
<td>O(min(i, n-i))*</td>
<td>O(min(i, n-i))</td>
<td>O(m)*</td>
<td>O(min(i, n-i))</td>
</tr>
<tr>
<td>DList</td>
<td>O(min(i, n-i))</td>
<td>O(min(i, n-i))</td>
<td>O(min(i, n-i))</td>
<td>O(1)</td>
<td>O(min(i, n-i))</td>
</tr>
<tr>
<td>Bitv</td>
<td>O(1)</td>
<td>O(n-i)*</td>
<td>O(n-i)</td>
<td>O(m)*</td>
<td>O(n-i)</td>
</tr>
</tbody></table>

<p>Note that where ties occur, Vec is generally going to be faster than RingBuf, and RingBuf
is generally going to be faster than DList. Bitv is not a general purpose collection, and
therefore cannot reasonably be compared.</p>

<h2 id="maps" class='section-header'><a
                           href="#maps">Maps</a></h2>
<p>For Sets, all operations have the cost of the equivalent Map operation. For BitvSet,
refer to VecMap.</p>

<table><thead>
<tr>
<th></th>
<th>get</th>
<th>insert</th>
<th>remove</th>
<th>predecessor</th>
</tr>
</thead><tbody>
<tr>
<td>HashMap</td>
<td>O(1)~</td>
<td>O(1)~*</td>
<td>O(1)~</td>
<td>N/A</td>
</tr>
<tr>
<td>BTreeMap</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>VecMap</td>
<td>O(1)</td>
<td>O(1)?</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
</tbody></table>

<p>Note that VecMap is <em>incredibly</em> inefficient in terms of space. The O(1) insertion time
assumes space for the element is already allocated. Otherwise, a large key may require a
massive reallocation, with no direct relation to the number of elements in the collection.
VecMap should only be seriously considered for small keys.</p>

<p>Note also that BTreeMap&#39;s precise preformance depends on the value of B.</p>

<h1 id="correct-and-efficient-usage-of-collections" class='section-header'><a
                           href="#correct-and-efficient-usage-of-collections">Correct and Efficient Usage of Collections</a></h1>
<p>Of course, knowing which collection is the right one for the job doesn&#39;t instantly
permit you to use it correctly. Here are some quick tips for efficient and correct
usage of the standard collections in general. If you&#39;re interested in how to use a
specific collection in particular, consult its documentation for detailed discussion
and code examples.</p>

<h2 id="capacity-management" class='section-header'><a
                           href="#capacity-management">Capacity Management</a></h2>
<p>Many collections provide several constructors and methods that refer to &quot;capacity&quot;.
These collections are generally built on top of an array. Optimally, this array would be
exactly the right size to fit only the elements stored in the collection, but for the
collection to do this would be very inefficient. If the backing array was exactly the
right size at all times, then every time an element is inserted, the collection would
have to grow the array to fit it. Due to the way memory is allocated and managed on most
computers, this would almost surely require allocating an entirely new array and
copying every single element from the old one into the new one. Hopefully you can
see that this wouldn&#39;t be very efficient to do on every operation.</p>

<p>Most collections therefore use an <em>amortized</em> allocation strategy. They generally let
themselves have a fair amount of unoccupied space so that they only have to grow
on occasion. When they do grow, they allocate a substantially larger array to move
the elements into so that it will take a while for another grow to be required. While
this strategy is great in general, it would be even better if the collection <em>never</em>
had to resize its backing array. Unfortunately, the collection itself doesn&#39;t have
enough information to do this itself. Therefore, it is up to us programmers to give it
hints.</p>

<p>Any <code>with_capacity</code> constructor will instruct the collection to allocate enough space
for the specified number of elements. Ideally this will be for exactly that many
elements, but some implementation details may prevent this. <code>Vec</code> and <code>RingBuf</code> can
be relied on to allocate exactly the requested amount, though. Use <code>with_capacity</code>
when you know exactly how many elements will be inserted, or at least have a
reasonable upper-bound on that number.</p>

<p>When anticipating a large influx of elements, the <code>reserve</code> family of methods can
be used to hint to the collection how much room it should make for the coming items.
As with <code>with_capacity</code>, the precise behavior of these methods will be specific to
the collection of interest.</p>

<p>For optimal performance, collections will generally avoid shrinking themselves.
If you believe that a collection will not soon contain any more elements, or
just really need the memory, the <code>shrink_to_fit</code> method prompts the collection
to shrink the backing array to the minimum size capable of holding its elements.</p>

<p>Finally, if ever you&#39;re interested in what the actual capacity of the collection is,
most collections provide a <code>capacity</code> method to query this information on demand.
This can be useful for debugging purposes, or for use with the <code>reserve</code> methods.</p>

<h2 id="iterators" class='section-header'><a
                           href="#iterators">Iterators</a></h2>
<p>Iterators are a powerful and robust mechanism used throughout Rust&#39;s standard
libraries. Iterators provide a sequence of values in a generic, safe, efficient
and convenient way. The contents of an iterator are usually <em>lazily</em> evaluated,
so that only the values that are actually needed are ever actually produced, and
no allocation need be done to temporarily store them. Iterators are primarily
consumed using a <code>for</code> loop, although many functions also take iterators where
a collection or sequence of values is desired.</p>

<p>All of the standard collections provide several iterators for performing bulk
manipulation of their contents. The three primary iterators almost every collection
should provide are <code>iter</code>, <code>iter_mut</code>, and <code>into_iter</code>. Some of these are not
provided on collections where it would be unsound or unreasonable to provide them.</p>

<p><code>iter</code> provides an iterator of immutable references to all the contents of a
collection in the most &quot;natural&quot; order. For sequence collections like <code>Vec</code>, this
means the items will be yielded in increasing order of index starting at 0. For ordered
collections like <code>BTreeMap</code>, this means that the items will be yielded in sorted order.
For unordered collections like <code>HashMap</code>, the items will be yielded in whatever order
the internal representation made most convenient. This is great for reading through
all the contents of the collection.</p>
<span class='rusttest'>fn main() {
    let vec = vec![1u, 2, 3, 4];
    for x in vec.iter() {
       println!(&quot;vec contained {}&quot;, x);
    }
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>vec</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1u</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>];
<span class='kw'>for</span> <span class='ident'>x</span> <span class='kw'>in</span> <span class='ident'>vec</span>.<span class='ident'>iter</span>() {
   <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;vec contained {}&quot;</span>, <span class='ident'>x</span>);
}
</pre>

<p><code>iter_mut</code> provides an iterator of <em>mutable</em> references in the same order as <code>iter</code>.
This is great for mutating all the contents of the collection.</p>
<span class='rusttest'>fn main() {
    let mut vec = vec![1u, 2, 3, 4];
    for x in vec.iter_mut() {
       *x += 1;
    }
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>vec</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1u</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>];
<span class='kw'>for</span> <span class='ident'>x</span> <span class='kw'>in</span> <span class='ident'>vec</span>.<span class='ident'>iter_mut</span>() {
   <span class='op'>*</span><span class='ident'>x</span> <span class='op'>+=</span> <span class='number'>1</span>;
}
</pre>

<p><code>into_iter</code> transforms the actual collection into an iterator over its contents
by-value. This is great when the collection itself is no longer needed, and the
values are needed elsewhere. Using <code>extend</code> with <code>into_iter</code> is the main way that
contents of one collection are moved into another. Calling <code>collect</code> on an iterator
itself is also a great way to convert one collection into another. Both of these
methods should internally use the capacity management tools discussed in the
previous section to do this as efficiently as possible.</p>
<span class='rusttest'>fn main() {
    let mut vec1 = vec![1u, 2, 3, 4];
    let vec2 = vec![10u, 20, 30, 40];
    vec1.extend(vec2.into_iter());
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>vec1</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1u</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>];
<span class='kw'>let</span> <span class='ident'>vec2</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>10u</span>, <span class='number'>20</span>, <span class='number'>30</span>, <span class='number'>40</span>];
<span class='ident'>vec1</span>.<span class='ident'>extend</span>(<span class='ident'>vec2</span>.<span class='ident'>into_iter</span>());
</pre>
<span class='rusttest'>fn main() {
    use std::collections::RingBuf;
    
    let vec = vec![1u, 2, 3, 4];
    let buf: RingBuf&lt;uint&gt; = vec.into_iter().collect();
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>RingBuf</span>;

<span class='kw'>let</span> <span class='ident'>vec</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1u</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>];
<span class='kw'>let</span> <span class='ident'>buf</span>: <span class='ident'>RingBuf</span><span class='op'>&lt;</span><span class='ident'>uint</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>vec</span>.<span class='ident'>into_iter</span>().<span class='ident'>collect</span>();
</pre>

<p>Iterators also provide a series of <em>adapter</em> methods for performing common tasks to
sequences. Among the adapters are functional favorites like <code>map</code>, <code>fold</code>, <code>skip</code>,
and <code>take</code>. Of particular interest to collections is the <code>rev</code> adapter, that
reverses any iterator that supports this operation. Most collections provide reversible
iterators as the way to iterate over them in reverse order.</p>
<span class='rusttest'>fn main() {
    let vec = vec![1u, 2, 3, 4];
    for x in vec.iter().rev() {
       println!(&quot;vec contained {}&quot;, x);
    }
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>vec</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1u</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>];
<span class='kw'>for</span> <span class='ident'>x</span> <span class='kw'>in</span> <span class='ident'>vec</span>.<span class='ident'>iter</span>().<span class='ident'>rev</span>() {
   <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;vec contained {}&quot;</span>, <span class='ident'>x</span>);
}
</pre>

<p>Several other collection methods also return iterators to yield a sequence of results
but avoid allocating an entire collection to store the result in. This provides maximum
flexibility as <code>collect</code> or <code>extend</code> can be called to &quot;pipe&quot; the sequence into any
collection if desired. Otherwise, the sequence can be looped over with a <code>for</code> loop. The
iterator can also be discarded after partial use, preventing the computation of the unused
items.</p>

<h2 id="entries" class='section-header'><a
                           href="#entries">Entries</a></h2>
<p>The <code>entry</code> API is intended to provide an efficient mechanism for manipulating
the contents of a map conditionally on the presence of a key or not. The primary
motivating use case for this is to provide efficient accumulator maps. For instance,
if one wishes to maintain a count of the number of times each key has been seen,
they will have to perform some conditional logic on whether this is the first time
the key has been seen or not. Normally, this would require a <code>find</code> followed by an
<code>insert</code>, effectively duplicating the search effort on each insertion.</p>

<p>When a user calls <code>map.entry(&amp;key)</code>, the map will search for the key and then yield
a variant of the <code>Entry</code> enum.</p>

<p>If a <code>Vacant(entry)</code> is yielded, then the key <em>was not</em> found. In this case the
only valid operation is to <code>set</code> the value of the entry. When this is done,
the vacant entry is consumed and converted into a mutable reference to the
the value that was inserted. This allows for further manipulation of the value
beyond the lifetime of the search itself. This is useful if complex logic needs to
be performed on the value regardless of whether the value was just inserted.</p>

<p>If an <code>Occupied(entry)</code> is yielded, then the key <em>was</em> found. In this case, the user
has several options: they can <code>get</code>, <code>set</code>, or <code>take</code> the value of the occupied
entry. Additionally, they can convert the occupied entry into a mutable reference
to its value, providing symmetry to the vacant <code>set</code> case.</p>

<h3 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h3>
<p>Here are the two primary ways in which <code>entry</code> is used. First, a simple example
where the logic performed on the values is trivial.</p>

<h4 id="counting-the-number-of-times-each-character-in-a-string-occurs" class='section-header'><a
                           href="#counting-the-number-of-times-each-character-in-a-string-occurs">Counting the number of times each character in a string occurs</a></h4><span class='rusttest'>fn main() {
    use std::collections::btree_map::{BTreeMap, Occupied, Vacant};
    
    let mut count = BTreeMap::new();
    let message = &quot;she sells sea shells by the sea shore&quot;;
    
    for c in message.chars() {
        match count.entry(c) {
            Vacant(entry) =&gt; { entry.insert(1u); },
            Occupied(mut entry) =&gt; *entry.get_mut() += 1,
        }
    }
    
    assert_eq!(count.get(&amp;&#39;s&#39;), Some(&amp;8));
    
    println!(&quot;Number of occurences of each character&quot;);
    for (char, count) in count.iter() {
        println!(&quot;{}: {}&quot;, char, count);
    }
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>btree_map</span>::{<span class='ident'>BTreeMap</span>, <span class='ident'>Occupied</span>, <span class='ident'>Vacant</span>};

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>count</span> <span class='op'>=</span> <span class='ident'>BTreeMap</span>::<span class='ident'>new</span>();
<span class='kw'>let</span> <span class='ident'>message</span> <span class='op'>=</span> <span class='string'>&quot;she sells sea shells by the sea shore&quot;</span>;

<span class='kw'>for</span> <span class='ident'>c</span> <span class='kw'>in</span> <span class='ident'>message</span>.<span class='ident'>chars</span>() {
    <span class='kw'>match</span> <span class='ident'>count</span>.<span class='ident'>entry</span>(<span class='ident'>c</span>) {
        <span class='ident'>Vacant</span>(<span class='ident'>entry</span>) <span class='op'>=&gt;</span> { <span class='ident'>entry</span>.<span class='ident'>insert</span>(<span class='number'>1u</span>); },
        <span class='ident'>Occupied</span>(<span class='kw-2'>mut</span> <span class='ident'>entry</span>) <span class='op'>=&gt;</span> <span class='op'>*</span><span class='ident'>entry</span>.<span class='ident'>get_mut</span>() <span class='op'>+=</span> <span class='number'>1</span>,
    }
}

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>count</span>.<span class='ident'>get</span>(<span class='kw-2'>&amp;</span><span class='string'>&#39;s&#39;</span>), <span class='prelude-val'>Some</span>(<span class='kw-2'>&amp;</span><span class='number'>8</span>));

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Number of occurences of each character&quot;</span>);
<span class='kw'>for</span> (<span class='ident'>char</span>, <span class='ident'>count</span>) <span class='kw'>in</span> <span class='ident'>count</span>.<span class='ident'>iter</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}: {}&quot;</span>, <span class='ident'>char</span>, <span class='ident'>count</span>);
}
</pre>

<p>When the logic to be performed on the value is more complex, we may simply use
the <code>entry</code> API to ensure that the value is initialized, and perform the logic
afterwards.</p>

<h4 id="tracking-the-inebriation-of-customers-at-a-bar" class='section-header'><a
                           href="#tracking-the-inebriation-of-customers-at-a-bar">Tracking the inebriation of customers at a bar</a></h4><span class='rusttest'>fn main() {
    use std::collections::btree_map::{BTreeMap, Occupied, Vacant};
    
    // A client of the bar. They have an id and a blood alcohol level.
    struct Person { id: u32, blood_alcohol: f32 };
    
    // All the orders made to the bar, by client id.
    let orders = vec![1,2,1,2,3,4,1,2,2,3,4,1,1,1];
    
    // Our clients.
    let mut blood_alcohol = BTreeMap::new();
    
    for id in orders.into_iter() {
        // If this is the first time we&#39;ve seen this customer, initialize them
        // with no blood alcohol. Otherwise, just retrieve them.
        let person = match blood_alcohol.entry(id) {
            Vacant(entry) =&gt; entry.insert(Person{id: id, blood_alcohol: 0.0}),
            Occupied(entry) =&gt; entry.into_mut(),
        };
    
        // Reduce their blood alcohol level. It takes time to order and drink a beer!
        person.blood_alcohol *= 0.9;
    
        // Check if they&#39;re sober enough to have another beer.
        if person.blood_alcohol &gt; 0.3 {
            // Too drunk... for now.
            println!(&quot;Sorry {}, I have to cut you off&quot;, person.id);
        } else {
            // Have another!
            person.blood_alcohol += 0.1;
        }
    }
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>btree_map</span>::{<span class='ident'>BTreeMap</span>, <span class='ident'>Occupied</span>, <span class='ident'>Vacant</span>};

<span class='comment'>// A client of the bar. They have an id and a blood alcohol level.</span>
<span class='kw'>struct</span> <span class='ident'>Person</span> { <span class='ident'>id</span>: <span class='ident'>u32</span>, <span class='ident'>blood_alcohol</span>: <span class='ident'>f32</span> };

<span class='comment'>// All the orders made to the bar, by client id.</span>
<span class='kw'>let</span> <span class='ident'>orders</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>,<span class='number'>2</span>,<span class='number'>1</span>,<span class='number'>2</span>,<span class='number'>3</span>,<span class='number'>4</span>,<span class='number'>1</span>,<span class='number'>2</span>,<span class='number'>2</span>,<span class='number'>3</span>,<span class='number'>4</span>,<span class='number'>1</span>,<span class='number'>1</span>,<span class='number'>1</span>];

<span class='comment'>// Our clients.</span>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>blood_alcohol</span> <span class='op'>=</span> <span class='ident'>BTreeMap</span>::<span class='ident'>new</span>();

<span class='kw'>for</span> <span class='ident'>id</span> <span class='kw'>in</span> <span class='ident'>orders</span>.<span class='ident'>into_iter</span>() {
    <span class='comment'>// If this is the first time we&#39;ve seen this customer, initialize them</span>
    <span class='comment'>// with no blood alcohol. Otherwise, just retrieve them.</span>
    <span class='kw'>let</span> <span class='ident'>person</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>blood_alcohol</span>.<span class='ident'>entry</span>(<span class='ident'>id</span>) {
        <span class='ident'>Vacant</span>(<span class='ident'>entry</span>) <span class='op'>=&gt;</span> <span class='ident'>entry</span>.<span class='ident'>insert</span>(<span class='ident'>Person</span>{<span class='ident'>id</span>: <span class='ident'>id</span>, <span class='ident'>blood_alcohol</span>: <span class='number'>0.0</span>}),
        <span class='ident'>Occupied</span>(<span class='ident'>entry</span>) <span class='op'>=&gt;</span> <span class='ident'>entry</span>.<span class='ident'>into_mut</span>(),
    };

    <span class='comment'>// Reduce their blood alcohol level. It takes time to order and drink a beer!</span>
    <span class='ident'>person</span>.<span class='ident'>blood_alcohol</span> <span class='op'>*=</span> <span class='number'>0.9</span>;

    <span class='comment'>// Check if they&#39;re sober enough to have another beer.</span>
    <span class='kw'>if</span> <span class='ident'>person</span>.<span class='ident'>blood_alcohol</span> <span class='op'>&gt;</span> <span class='number'>0.3</span> {
        <span class='comment'>// Too drunk... for now.</span>
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Sorry {}, I have to cut you off&quot;</span>, <span class='ident'>person</span>.<span class='ident'>id</span>);
    } <span class='kw'>else</span> {
        <span class='comment'>// Have another!</span>
        <span class='ident'>person</span>.<span class='ident'>blood_alcohol</span> <span class='op'>+=</span> <span class='number'>0.1</span>;
    }
}
</pre>
</div><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table>
                    <tr>
                        <td><a class='stability Stable' title='Stable'></a><a class='mod' href='binary_heap/index.html'
                               title='std::collections::binary_heap'>binary_heap</a></td>
                        <td class='docblock short'><p>A priority queue implemented with a binary heap.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unstable' title='Unstable: RFC 509'></a><a class='mod' href='bitv/index.html'
                               title='std::collections::bitv'>bitv</a></td>
                        <td class='docblock short'></td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unstable' title='Unstable: RFC 509'></a><a class='mod' href='bitv_set/index.html'
                               title='std::collections::bitv_set'>bitv_set</a></td>
                        <td class='docblock short'></td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Stable' title='Stable'></a><a class='mod' href='btree_map/index.html'
                               title='std::collections::btree_map'>btree_map</a></td>
                        <td class='docblock short'></td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Stable' title='Stable'></a><a class='mod' href='btree_set/index.html'
                               title='std::collections::btree_set'>btree_set</a></td>
                        <td class='docblock short'></td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Stable' title='Stable'></a><a class='mod' href='dlist/index.html'
                               title='std::collections::dlist'>dlist</a></td>
                        <td class='docblock short'><p>A doubly-linked list with owned nodes.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Stable' title='Stable'></a><a class='mod' href='hash_map/index.html'
                               title='std::collections::hash_map'>hash_map</a></td>
                        <td class='docblock short'><p>A hashmap</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Stable' title='Stable'></a><a class='mod' href='hash_set/index.html'
                               title='std::collections::hash_set'>hash_set</a></td>
                        <td class='docblock short'><p>A hashset</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unstable' title='Unstable: module was recently added'></a><a class='mod' href='hash_state/index.html'
                               title='std::collections::hash_state'>hash_state</a></td>
                        <td class='docblock short'><p>Experimental support for providing custom hash algorithms to a HashMap and
HashSet.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Stable' title='Stable'></a><a class='mod' href='ring_buf/index.html'
                               title='std::collections::ring_buf'>ring_buf</a></td>
                        <td class='docblock short'><p>This crate implements a double-ended queue with <code>O(1)</code> amortized inserts and removals from both
ends of the container. It also has <code>O(1)</code> indexing like a vector. The contained elements are
not required to be copyable, and the queue will be sendable if the contained type is sendable.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unstable' title='Unstable'></a><a class='mod' href='vec_map/index.html'
                               title='std::collections::vec_map'>vec_map</a></td>
                        <td class='docblock short'><p>A simple map based on a vector for small integer keys. Space requirements
are O(highest integer key).</p>
</td>
                    </tr>
                </table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table>
                    <tr>
                        <td><a class='stability Stable' title='Stable'></a><a class='struct' href='struct.BTreeMap.html'
                               title='std::collections::BTreeMap'>BTreeMap</a></td>
                        <td class='docblock short'><p>A map based on a B-Tree.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Stable' title='Stable'></a><a class='struct' href='struct.BTreeSet.html'
                               title='std::collections::BTreeSet'>BTreeSet</a></td>
                        <td class='docblock short'><p>A set based on a B-Tree.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Stable' title='Stable'></a><a class='struct' href='struct.BinaryHeap.html'
                               title='std::collections::BinaryHeap'>BinaryHeap</a></td>
                        <td class='docblock short'><p>A priority queue implemented with a binary heap.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unstable' title='Unstable: RFC 509'></a><a class='struct' href='struct.Bitv.html'
                               title='std::collections::Bitv'>Bitv</a></td>
                        <td class='docblock short'><p>The bitvector type.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unstable' title='Unstable: RFC 509'></a><a class='struct' href='struct.BitvSet.html'
                               title='std::collections::BitvSet'>BitvSet</a></td>
                        <td class='docblock short'><p>An implementation of a set using a bit vector as an underlying
representation for holding unsigned numerical elements.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Stable' title='Stable'></a><a class='struct' href='struct.DList.html'
                               title='std::collections::DList'>DList</a></td>
                        <td class='docblock short'><p>A doubly-linked list.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Stable' title='Stable'></a><a class='struct' href='struct.HashMap.html'
                               title='std::collections::HashMap'>HashMap</a></td>
                        <td class='docblock short'><p>A hash map implementation which uses linear probing with Robin
Hood bucket stealing.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Stable' title='Stable'></a><a class='struct' href='struct.HashSet.html'
                               title='std::collections::HashSet'>HashSet</a></td>
                        <td class='docblock short'><p>An implementation of a hash set using the underlying representation of a
HashMap where the value is (). As with the <code>HashMap</code> type, a <code>HashSet</code>
requires that the elements implement the <code>Eq</code> and <code>Hash</code> traits.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Stable' title='Stable'></a><a class='struct' href='struct.RingBuf.html'
                               title='std::collections::RingBuf'>RingBuf</a></td>
                        <td class='docblock short'><p><code>RingBuf</code> is a circular buffer, which can be used as a double-ended queue efficiently.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unstable' title='Unstable'></a><a class='struct' href='struct.VecMap.html'
                               title='std::collections::VecMap'>VecMap</a></td>
                        <td class='docblock short'><p>A map optimized for small integer keys.</p>
</td>
                    </tr>
                </table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table>
                    <tr>
                        <td><a class='stability Unstable' title='Unstable'></a><a class='enum' href='enum.Bound.html'
                               title='std::collections::Bound'>Bound</a></td>
                        <td class='docblock short'><p>An endpoint of a range of keys.</p>
</td>
                    </tr>
                </table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&larrb;</dt>
                <dd>Move up in search results</dd>
                <dt>&rarrb;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code>, <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
        </div>
    </div>

    

    <script>
        window.rootPath = "../../";
        window.currentCrate = "std";
        window.playgroundUrl = "http://play.rust-lang.org/";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    <script src="../../playpen.js"></script>
    <script async src="../../search-index.js"></script>
</body>
</html>